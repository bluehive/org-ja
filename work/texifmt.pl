#!/usr/bin/perl
# Auto warp script for a texinfo file generated by po4a-translate
#                               2011-08-27  Takaaki ISHIKAWA  <takaxp@ieee.org>
#
#  (*) If you are perl professional, please advice to me or improve this :-)
#
use strict;
use warnings;
use File::Copy;
use Encode;
use utf8;
use encoding 'utf8';
use open ":utf8";
use open ":std";

print "Make a new texi file with valid wrap for generateing an INFO file\n";

my $backup = 'org-ja_bak.texi';
my $texinfo = 'org-ja.texi';
my $wrap = '76';
my $stringcode = 'utf-8';

# Backup the target file.
(-f $texinfo) or die ("$texinfo: $!\n");
(-f $backup) or die ("$backup: $!, please touch $backup\n");
copy($texinfo, $backup) or die ("ERROR: FILE COPY $!");

# Read the original texinfo file generated by po4a-translate
open(IN,"< $texinfo") or die("ERROR: OPEN A FILE $!");
my @src = <IN>;
close(IN);

# debug
my $bytecount_called = 0;

# Replace (，．) with (、。)
my $dst = &replace_marks(\@src);

# Replace \p{UTF-8}\n\p{UTF-8} to \p{UTF-8}\p{UTF-8}
#$dst = &subs_unexpected_break($dst);

$dst = &get_valid_texinfo_data($dst);

#&subs_unexpected_break(\@src);
#my $dst = &get_valid_texinfo_data(\@src);

# out
print "CALL &bytecount = ".$bytecount_called."\n";

open(OUT,"> $texinfo") or die("ERROR: FAIL TO OPEN A FILE $!");
foreach my $line (@{$dst}){
    chomp($line);
    print OUT $line."\n";
}
close(OUT);

1;

###############################################################################
sub replace_marks {
    my @dst = ();
    my $src = shift;
    foreach my $line (@$src){
	$line =~ s/．/。/g;
	$line =~ s/，/、/g;
	push(@dst, $line);
    }
    return \@dst;
}

sub bytecount {
    ++$bytecount_called;
    my $line = shift;
    my $length = length(encode($stringcode,$$line)); # abc[U][U]=3+6=9
    my $ascii=0;
    for(my $i=0; $i<length($$line); ++$i){             # abc[U][U]=5
	if(&is_ascii(encode($stringcode,substr($$line,$i,1)))){ ++$ascii; }
    }
    my $utf = $length-$ascii;
    my $width = 2*$utf/3+$ascii;
#    print $length."\t".$width."\t".$ascii."\t".$utf."\t(".$$line.")\n";
    return $width;
}

sub is_unexpected_linebreak {
    my $line = shift;
    my $result = 0;
    if(&is_command_divided($$line)){
	print "HIT: command division\n";
	return 1;
    }
#    if($line =~ /@\:\s?$/){
#	return 1;
#    }
    return 0;
}
# The line has a divided texinfo command (e.g. @i{Agenda\n)
sub is_command_divided {
    $_[0] =~ /\@.+{[^}]+$/;
}
sub is_utf {
    $_[0] !~ /[\x20-\x7f]/; # ascii codes
}
sub is_ascii {
    $_[0] =~ /[\x20-\x7f]/; # ascii codes
}
sub get_split_position {
    my $words = shift;
    my $anchor = 0;
    my $count = 0;
    my $buffer = "";
    if(@$words==0){
	return 0;
    }
    for(my $i=0; $i<@$words; ++$i){
	if(&is_ascii($$words[$i])){
	    ++$count;
	}else{
	    $count += 2;
	}

	$buffer .= $$words[$i];
	if(&is_utf($$words[$i-1]) && &is_ascii($$words[$i])){
	    $anchor = $i;
	}
#	if($$words[$i-1] eq " "){
#	    $anchor = $i;
#	}
	# update virtual_wrap
	my $virtual_wrap = &get_virtual_wrap(\$buffer);
#	$virtual_wrap = $wrap;
	if($count > $virtual_wrap){
#	    print "break: $anchor\t".$$words[$i-1]."\t".$$words[$i]."\n";
	    if( &is_ascii($$words[$i-1]) && &is_ascii($$words[$i]) ){
		return $anchor;
	    }
	    return $i;
	}
    }
#    if( &is_ascii($$words[$#$words-1]) && &is_ascii($$words[$#$words]) ){
#	return $anchor;
#    }

    return @$words;
}
sub get_virtual_wrap {
    my $virtual_wrap = $wrap;
    my $buffer = shift;
    if($$buffer =~ m/(\@[^}]+){/g){
#	print "VIRTUAL: $1\n";
#	$virtual_wrap += &bytecount(\$1);
	if($1 eq "\@LaTeX"){
	    $virtual_wrap += 3;
	}else{
	    $virtual_wrap += length($1);
	}
    }
    return $virtual_wrap;
}
sub get_last_command {
    my $buffer = shift;
    if($$buffer =~ /\@([^}]+){$/){
	return $1;
    }
    return "";
}
sub is_exception {
    $_[0] =~ /^\@c|^\@r|^\@set|^\@item|^\@node|^\*\s.+\:\:/;
}
sub is_conflict_free {
    ($_[0] eq 'i' || $_[0] eq 'b') ? return 1 : return 0;
#    ($_[0] eq 'i' || $_[0] eq 'b'|| $_[0] eq 'footnote') ? return 1 : return 0;
}
sub get_valid_texinfo_data {
    my $buffer = "";
    my $src = shift;
    my @dst = ();
    print "=================== START ==========================\n";
    foreach my $line (@{$src}){
	chomp($line);
	if(!&is_unexpected_linebreak(\$line)){
	    $line = $buffer.$line;
	    my $count = &bytecount(\$line);
#	    print "$count:\t$line\n";
	    if($count > $wrap && !&is_exception($line)){
		# many translated sentences will pass through
		print ">>>> INPUT::\n".$line."\n";
		my $wraped_string = &get_wraped_string_new(\$line);
#		my $wraped_string = &get_wraped_string(\$line);
		print "<<<< OUTPUT::\n".$$wraped_string."\n----------------\n\n";
		push(@dst,$$wraped_string);
	    }else{
		# many original sentences will pass through
		push(@dst,$line);
	    }
	    $buffer = "";
	}else{
	    # Replace "\n" to " ".
	    # (e.g. @i{Agenda\nView} to @i{Agenda View}
	    $buffer .= $line." ";
	    print "buffer = ".$buffer."\n";
	}
    }
    print "==================== END  =========================\n";
    return \@dst;
}

sub subs_unexpected_break {
    my @dst = ();
    my $buffer = "";
    # 翻訳データ中の不用意な半角スペースを抑制可能．
    foreach my $line (@{$_[0]}){
	chomp($line);
	push(@dst,$line);
	if($line eq ""){
	    #buffer を解析
	    my @words = split //, $buffer; # UTF を考慮して全文字を配列化
	    for(my $i=1; $i<$#words-1; $i++){
		if($words[$i] =~ /[\n]/ &&
		   is_utf($words[$i-1])  && is_utf($words[$i+1])){
		    print "hit ".$words[$i-1]."\t".$words[$i+1]."\n";
		}
	    }
	    $buffer = "";
	}else{
	    $buffer .= $line."\n";
	}
    }

#    for(my $i=0; $i<$#{$_[0]}; $i++){
#	chomp(${$_[0]}[$i]);
#	$buffer1 = ${$_[0]}[$i];
#	print $buffer1."\n";
#    }
    return \@dst;
}

sub flash_buffer {
    my($b1, $b2) = @_;
    $$b1 = "";
    $$b2 = "";
}

# This function will insert LF code into appropriate positions on line.
# e.g.
# 1: ...............................$wrap
# 2: ..............................LF...|     no control code
# 3: .............................LF....|     no control code
# 4: ..........................LF@hoge{...}   (@ref{})
# 5: ....@hoge{...................LF....|     (@i{}, @b{})
# 6: ....@hoge{................LF@hoge{...}   (@i{...@ref{})
#
sub get_wraped_string {
    my $line = shift;
    my @words = split //, $$line;
    my $stream = ""; # line with LF codes
    my $buffer = "";
    my $word_count = 0;
    my @code_stack = ();

    foreach my $word (@words){
	$word_count += &bytecount(\$word);

	if($word =~ /^\@$/){ # Never insert LF code
	    push(@code_stack, $word);

	}else{
	    if($#code_stack < 0){ # No texinfo code nesting
		$buffer .= $word;
		if($word_count > $wrap){
		    print $word_count."\n";
		    &insert_linebreak(\$stream,\$buffer);
		    $word_count = &bytecount(\$buffer);
		}

	    }else{                # texinfo code nesting
		$code_stack[$#code_stack] .= $word;
		# Insert a Line Feed code ( \n@hoge{ or @hoge{...\n)
		if($word eq "}" && $code_stack[$#code_stack] =~ /^\@(.+){/){
		    # 制御文が判明したらカウントを戻す
		    $word_count -= &bytecount(\$1)+1; # 1 = (@,{,})-(`,')
		}

		if($word_count >= $wrap){
		    if($code_stack[$#code_stack] =~ /^\@(.+){/){
			if(&is_conflict_free($1)){
			    # OK insert \n middle of the texinfo code
			    $code_stack[$#code_stack] .= "\n";
			}else{
			    $code_stack[$#code_stack]
				= "\n".$code_stack[$#code_stack];
			}
			print $word_count."\n";
			$word_count = 0;
		    }
		}

		# Check completion of texinfo code (e.g. @hoge{ })
		if($word eq "}"){
		    if($#code_stack > 0){ # multiple nesting
			$code_stack[$#code_stack-1]
			    .= $code_stack[$#code_stack];
#			print $code_stack[$#code_stack]."\n";
		    }elsif($#code_stack == 0){ # single nesting
			$stream .= $code_stack[$#code_stack];
		    }
		    pop(@code_stack);
		}
	    }
	}
    }

    if($buffer ne ""){
	$stream .= $buffer."\n";
    }

    # for a case of missing '}' (e.g. @hoge{ ... @hoge{ ... } )
    if($#code_stack >= 0){
	foreach my $line (@code_stack){
	    $stream .= $line;
	}
    }
    return \$stream;
}

sub get_wraped_string_new {
    my $line = shift;
    my @words = split //, $$line;
    print "文字数 = ".@words.", バイト数 = ".&bytecount($line)."\n";

    my $stream = ""; # line with LF codes
    my $buffer = $$line;
    my $word_count = &bytecount($line);
    my @code_stack = ();

    my $prev_count = 0;
    while($word_count > $wrap){
	print "current count = ".$word_count."\n";
	&insert_linebreak(\$stream,\$buffer);
	$word_count = &bytecount(\$buffer);
	# avoid infinity loop
	if($word_count == $prev_count){
	    $word_count = 0;
	}
	$prev_count = $word_count;
    }	

#    foreach my $word (@words){
#	$word_count += &bytecount(\$word);
#	$buffer .= $word;
#	if($word_count > $wrap){
#	    print $word_count."\n";
#	    &insert_linebreak(\$buffer,\$stream);
#	    $word_count = &bytecount(\$buffer);
#	}
#    }

    if($buffer ne ""){
	$stream .= $buffer."\n";
    }
    return \$stream;
}

sub insert_linebreak {
    my ($stream, $buffer) = @_;
    my ($buffer1, $buffer2) = &split_buffer($buffer);
    $$stream .= $$buffer1."\n";
    $$buffer = $$buffer2;
}

# Get the first index of the 2nd buffer
sub split_buffer {
    my $buffer = shift;
    my @words = split //, $$buffer;
    my $split_position = &get_split_position(\@words);
    my $buffer1 = "";
    my $buffer2 = "";
    if($split_position == 0){
	print "No stack.\n";
	return ($buffer, \$buffer2);
    }

    for(my $i=0; $i<$split_position; ++$i){
	$buffer1 .= $words[$i];
    }
    for(my $i=$split_position; $i<@words; ++$i){
	$buffer2 .= $words[$i];
    }
#    print "(".$split_position."/".$#words.")\n";
#    print $buffer1."<=>".$buffer2."\n";
    return(\$buffer1, \$buffer2);
}

sub brackets_validation {
    my $line = shift;
    my @words = split //, $$line;
    my $begin_count = 0;
    my $end_count = 0;
    foreach my $word (@words){
	if( $word eq "{" ){ ++$begin_count; }
	if( $word eq "}" ){ ++$end_count; }
    }
    if($begin_count == $end_count){
	return 1;
    }
    return 0;
}
